<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Right Side Christmas Tree</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            background: radial-gradient(circle at center, #1a0b2e 0%, #000000 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
        }
        #text-overlay {
            position: absolute;
            top: 50%;
            /* 修改 1: 文字移到左侧 (原为 50%) */
            left: 50%; 
            transform: translate(-50%, -50%);
            pointer-events: none;
            text-align: center; /* 或者 left */
            z-index: 10;
        }
        h1 {
            font-family: 'Brush Script MT', 'Comic Sans MS', cursive;
            color: #fff;
            font-size: 5rem;
            margin: 0;
            text-shadow: 0 0 10px #fff, 0 0 20px #ff0055, 0 0 40px #ff0055;
            animation: pulse 3s infinite ease-in-out;
            opacity: 0.95;
            white-space: nowrap; /* 防止文字换行 */
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
        }
    </style>
</head>
<body>

    <div id="text-overlay">
        <h1>Merry Christmas</h1>
        <h1>祝大家圣诞快乐!</h1>
    </div>
    <canvas id="canvas"></canvas>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let w, h;
    let particles = [];
    let angle = 0; 
    
    const sparkImage = new Image();
    sparkImage.src = 'spark.png'; 

    const CONFIG = {
        particleCount: 5000, 
        fov: 600,
        spinSpeed: 0.002, 
        colorPalette: [
            '#ff0055', '#ff0000', '#ffcc00', '#ffffff', 
            '#00ff88', '#006633', '#00ccff', '#d642ff'
        ]
    };

    const spriteCache = {}; 

    function resize() {
        w = canvas.width = window.innerWidth;
        h = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function prepareSprites() {
        CONFIG.colorPalette.forEach(color => createSprite(color));
        createSprite('#ffd700'); 
        createSprite('#ff3333'); 
        createSprite('#228b22'); 
    }

    function createSprite(color) {
        const buffer = document.createElement('canvas');
        const size = 32; 
        buffer.width = size; buffer.height = size;
        const bCtx = buffer.getContext('2d');
        bCtx.fillStyle = color;
        bCtx.fillRect(0, 0, size, size);
        bCtx.globalCompositeOperation = 'destination-in';
        bCtx.drawImage(sparkImage, 0, 0, size, size);
        spriteCache[color] = buffer;
    }

    class Particle {
        constructor(type) {
            this.init(type);
        }

        init(type) {
            this.type = type;
            this.phase = Math.random() * Math.PI * 2;
            this.color = CONFIG.colorPalette[Math.floor(Math.random() * CONFIG.colorPalette.length)];

            if (type === 'tree') {
                const layer = Math.random(); 
                const maxRadius = layer * 220;
                const y = -300 + layer * 600; 

                const isCore = Math.random() < 0.4; 

                let radius;
                if (isCore) {
                    radius = maxRadius * Math.sqrt(Math.random()) * 0.7;
                    this.baseSize = Math.random() * 25 + 15; 
                    this.color = '#006633'; 
                    this.alphaFactor = 0.3; 
                } else {
                    radius = maxRadius * (0.7 + 0.3 * Math.sqrt(Math.random()));
                    this.baseSize = Math.random() * 6 + 3; 
                    this.color = Math.random() > 0.6 ? '#00ff88' : '#ffffff';
                    this.alphaFactor = 1.0;
                }

                const theta = layer * Math.PI * 60 + Math.random() * 2; 
                this.x = Math.cos(theta) * radius;
                this.y = y;
                this.z = Math.sin(theta) * radius;

            } else if (type === 'ribbon') {
                const layer = Math.random();
                const radius = layer * 225; 
                const y = -290 + layer * 590;
                const theta = layer * Math.PI * 15; 
                this.x = Math.cos(theta) * radius;
                this.y = y;
                this.z = Math.sin(theta) * radius;
                this.baseSize = Math.random() * 8 + 5;
                this.color = '#ffd700'; 
                this.alphaFactor = 1.0;

            } else if (type === 'ornament') {
                const layer = Math.random();
                const radius = layer * 235; 
                const y = -280 + layer * 580;
                const theta = Math.random() * Math.PI * 2;
                this.x = Math.cos(theta) * radius;
                this.y = y;
                this.z = Math.sin(theta) * radius;
                this.baseSize = Math.random() * 12 + 18; 
                const ballColors = ['#ff0000', '#ffd700', '#00ccff', '#ff0055'];
                this.color = ballColors[Math.floor(Math.random() * ballColors.length)];
                this.alphaFactor = 1.2; 

            } else if (type === 'floor') {
                const theta = Math.random() * Math.PI * 2;
                const r = 80 + Math.random() * 600; 
                this.x = Math.cos(theta) * r;
                this.y = 320; 
                this.z = Math.sin(theta) * r;
                this.baseSize = Math.random() * 15 + 5;
                this.color = '#ffffff'; 
                this.alphaFactor = 0.5;

            } else if (type === 'topStar') {
                const points = 10;
                const side = Math.floor(Math.random() * points);
                const t = Math.random(); 
                const angleStep = Math.PI * 2 / points;
                const a1 = side * angleStep - Math.PI / 2;
                const a2 = (side + 1) * angleStep - Math.PI / 2;
                const r1 = (side % 2 === 0) ? 55 : 25; 
                const r2 = ((side + 1) % 2 === 0) ? 55 : 25;
                const x1 = Math.cos(a1) * r1;
                const y1 = Math.sin(a1) * r1;
                const x2 = Math.cos(a2) * r2;
                const y2 = Math.sin(a2) * r2;
                const edgeX = x1 + (x2 - x1) * t;
                const edgeY = y1 + (y2 - y1) * t;
                this.x = edgeX * (0.3 + 0.7 * Math.random()); 
                this.y = edgeY * (0.3 + 0.7 * Math.random()) - 340; 
                this.z = (Math.random() - 0.5) * 20; 
                this.baseSize = Math.random() * 20 + 20; 
                this.color = '#ffd700';
                this.alphaFactor = 1.2;

            } else if (type === 'snow') {
                const range = 2500;
                this.x = (Math.random() - 0.5) * range;
                this.y = (Math.random() - 0.5) * range; 
                this.z = (Math.random() - 0.5) * range;
                this.vy = 1 + Math.random() * 2; 
                this.baseSize = Math.random() * 6 + 4;
                this.color = '#ffffff'; 
                this.alphaFactor = 0.6;

            } else if (type === 'bgStar') {
                const range = 4000;
                this.x = (Math.random() - 0.5) * range;
                this.y = (Math.random() - 0.5) * range;
                this.z = (Math.random() - 0.5) * range;
                this.baseSize = Math.random() * 5 + 1;
                this.color = Math.random() < 0.5 ? '#ffffff' : '#00ccff';
                this.alphaFactor = 0.4;
            }
        }

        update() {
            this.phase += 0.05;
            if (this.type === 'snow') {
                this.y += this.vy;
                if (this.y > 1000) this.y = -1000;
            }
        }

        draw(centerX, centerY, rotationAngle) {
            let angleToUse = rotationAngle;
            if (this.type === 'bgStar') angleToUse = rotationAngle * 0.2;

            const cos = Math.cos(angleToUse);
            const sin = Math.sin(angleToUse);
            
            const rx = this.x * cos - this.z * sin;
            const rz = this.z * cos + this.x * sin;

            const cameraZ = rz + 800; 
            if (cameraZ <= 0) return; 

            const scale = CONFIG.fov / cameraZ;
            const x2d = centerX + rx * scale;
            const y2d = centerY + this.y * scale;

            const sprite = spriteCache[this.color];
            if (!sprite) return; 

            let blink = (Math.sin(this.phase) + 1) / 2;
            let alpha = 1;
            if (this.type === 'tree') {
                alpha = this.alphaFactor === 1.0 ? 0.8 + blink * 0.2 : 0.4;
            } else if (this.type === 'ribbon') {
                alpha = 0.8 + blink * 0.2;
            } else if (this.type === 'ornament') {
                alpha = 0.9; 
            } else {
                alpha = (0.5 + blink * 0.5) * this.alphaFactor;
            }

            const size = this.baseSize * scale;

            ctx.globalAlpha = alpha;
            ctx.drawImage(sprite, x2d - size / 2, y2d - size / 2, size, size);
        }
        
        getDepth(angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return this.z * cos + this.x * sin;
        }
    }

    function init() {
        particles = [];
        for (let i = 0; i < 5500; i++) particles.push(new Particle('tree'));
        for (let i = 0; i < 400; i++) particles.push(new Particle('ribbon'));
        for (let i = 0; i < 200; i++) particles.push(new Particle('ornament'));
        for (let i = 0; i < 1000; i++) particles.push(new Particle('floor'));
        for (let i = 0; i < 250; i++) particles.push(new Particle('topStar'));
        for (let i = 0; i < 2000; i++) particles.push(new Particle('snow'));
        for (let i = 0; i < 400; i++) particles.push(new Particle('bgStar'));
    }

    function loop() {
        ctx.clearRect(0, 0, w, h);
        ctx.globalCompositeOperation = 'lighter'; 

        particles.sort((a, b) => b.getDepth(angle) - a.getDepth(angle));

        // 修改 2: 在这里改变绘制中心点
        // w * 0.75 表示将中心设置在屏幕右侧 75% 的位置
        // 如果觉得太靠右，可以改为 0.7
        const treeCenterX = w * 0.75;
        const treeCenterY = h / 2;

        particles.forEach(p => {
            p.update();
            p.draw(treeCenterX, treeCenterY, angle);
        });

        angle += CONFIG.spinSpeed;
        requestAnimationFrame(loop);
    }

    sparkImage.onload = () => {
        prepareSprites();
        init();
        loop();
    };
    
    sparkImage.onerror = () => {
        const fCanvas = document.createElement('canvas');
        fCanvas.width = 32; fCanvas.height = 32;
        const fCtx = fCanvas.getContext('2d');
        const g = fCtx.createRadialGradient(16,16,0,16,16,16);
        g.addColorStop(0,'white'); g.addColorStop(1,'transparent');
        fCtx.fillStyle = g; fCtx.fillRect(0,0,32,32);
        sparkImage.src = fCanvas.toDataURL();
    };

</script>
</body>
</html>